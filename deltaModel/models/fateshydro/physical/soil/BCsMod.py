from physical.soil import SoilMod as F_soil


class bc_in_type():
    # I think those variables need to be defined by myself (First should be site attribute &
    # second should be layer thickness from ERA5)
    def __init__(self, soil_order):
        self.soil_order = soil_order

    def setAttrs(self, dz, zi, zsoi, sand_per, clay_per, om_frac):
        # ! layer thickness (m) --> input
        self.dz_sisl  = dz
        # ! interface level below a "z" level (m) this contains a zero index for surface but here ignored--> input
        self.zi_sisl  = zi

        # ! volumetric soil water at saturation (porosity)--> input
        # ! Clapp and Hornberger "b"--> input
        # ! minimum soil suction (mm)--> input
        # ! hydraulic conductivity at saturation (mm H2O /s)
        soilBCs= F_soil.initsoilBCs(ipedof      =self.soil_order,
                                    sand        =sand_per,
                                    clay        =clay_per,
                                    om_frac     = om_frac,
                                    zsoi        = zsoi)
        self.watsat_sisl, self.bsw_sisl, self.sucsat_sisl, self.hksat_sisl = soilBCs

    def subsetAttrs(self, indices):
        return {attr: getattr(self, attr)[indices] for attr in ['watsat_sisl', 'dz_sisl'] if hasattr(self, attr)}

    def updateAttrs(self, subsetAttrs):
        for attr, value in subsetAttrs.items():
            setattr(self, attr, value)
        return

    def UpdateStates(self, SM_liq, SM_ice, t, watsat_sisl, dz_sisl):
        self.h2o_liq_sisl = SM_liq[t]
        # ! effective porosity = porosity - vol_ice (nlevgrnd)
        self.eff_porosity_sl = F_soil.get_effporosity(watsat_col = watsat_sisl,
                                                      h2osoi_ice = SM_ice[t],
                                                      dz         = dz_sisl)
    #def InitStates(self, SM_liq, SM_ice):
    #     self.h2osoi_liq = SM_liq
    #     self.h2osoi_ice = SM_ice
    #     # ! Liquid water mass in each layer (kg/m2) --> I think this should be changing each timestep
    #     self.h2o_liq_sisl = self.h2osoi_liq[:,:,0] # extract the first timestep
    #
    #     # ! effective porosity = porosity - vol_ice (nlevgrnd)
    #     self.eff_porosity_sl = F_soil.get_effporosity(watsat_col = self.watsat_sisl,
    #                                                   h2osoi_ice = self.h2osoi_ice[:,:,0],
    #                                                   dz         = self.dz_sisl)
    #
    # def UpdateStates(self, t):
    #     self.h2o_liq_sisl    = self.h2osoi_liq[:,:,t]
    #     self.eff_porosity_sl = F_soil.get_effporosity(watsat_col = self.watsat_sisl,
    #                                                   h2osoi_ice = self.h2osoi_ice[:,:,t],# extract the current timestep
    #                                                   dz         = self.dz_sisl)


# class bc_out_type():
#     def __init__(self, nsites, nlevsoil_in):
#         # ! Water flux from soil into root by site and soil layer
#         # ! [mm H2O/s] [+ into root]
#         self.qflx_soil2root_sisl = torch.zeros((nsites, nlevsoil_in), dtype = fates_r8)
#
#
#         # Water flux runoff generated by root to soil flux
#         # super-saturating the soils
#         # This does seem unlikely, but we need accomodate
#         # small fluxes for various reasons[mm H2O/s]
#         self.qflx_ro_sisl        = torch.zeros((nsites, nlevsoil_in), dtype = fates_r8)
#
#         # ! stored water in LIVE+DEAD vegetation (kg/m2 H2O)
#         # ! Assuming density of 1Mg/m3 ~= mm/m2 H2O
#         # ! This must be set and transfered prior to clm_drv()
#         # ! following the calls to ed_update_site()
#         self.plant_stored_h2o_si = torch.zeros((nsites), dtype = fates_r8)
